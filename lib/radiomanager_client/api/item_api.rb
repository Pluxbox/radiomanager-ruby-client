=begin
#RadioManager

#This OpenAPI 3 Document describes the functionality of the API v2 of RadioManager. Note that no rights can be derived from this Document and the true functionality of the API might differ.

The version of the OpenAPI document: 2.0
Contact: support@pluxbox.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.2.1

=end

require 'cgi'

module RadioManagerClient
  class ItemApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create an new item.
    # Create item.
    # @param item_data_input [ItemDataInput] Data **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2002]
    def create_item(item_data_input, opts = {})
      data, _status_code, _headers = create_item_with_http_info(item_data_input, opts)
      data
    end

    # Create an new item.
    # Create item.
    # @param item_data_input [ItemDataInput] Data **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2002, Integer, Hash)>] InlineResponse2002 data, response status code and response headers
    def create_item_with_http_info(item_data_input, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.create_item ...'
      end
      # verify the required parameter 'item_data_input' is set
      if @api_client.config.client_side_validation && item_data_input.nil?
        fail ArgumentError, "Missing the required parameter 'item_data_input' when calling ItemApi.create_item"
      end
      # resource path
      local_var_path = '/items'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(item_data_input)

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse2002'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.create_item",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#create_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Post a current playing item, keep structure
    # Post current playing Item. Can be existing Item referenced by external_id. When Items are moved, this function **will attempt to** keep Items' ModelType structure in rundown.
    # @param import_item [ImportItem] Data **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [ItemResult]
    def current_item_post_structure(import_item, opts = {})
      data, _status_code, _headers = current_item_post_structure_with_http_info(import_item, opts)
      data
    end

    # Post a current playing item, keep structure
    # Post current playing Item. Can be existing Item referenced by external_id. When Items are moved, this function **will attempt to** keep Items&#39; ModelType structure in rundown.
    # @param import_item [ImportItem] Data **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [Array<(ItemResult, Integer, Hash)>] ItemResult data, response status code and response headers
    def current_item_post_structure_with_http_info(import_item, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.current_item_post_structure ...'
      end
      # verify the required parameter 'import_item' is set
      if @api_client.config.client_side_validation && import_item.nil?
        fail ArgumentError, "Missing the required parameter 'import_item' when calling ItemApi.current_item_post_structure"
      end
      # resource path
      local_var_path = '/items/current/structure'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(import_item)

      # return_type
      return_type = opts[:debug_return_type] || 'ItemResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.current_item_post_structure",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#current_item_post_structure\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Post current playing Item
    # Post current playing Item. Can be existing Item referenced by external_id. When Items are moved, this function **will not keep** Items' ModelType structure in rundown.
    # @param import_item [ImportItem] Data **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [ItemResult]
    def current_item_post_timing(import_item, opts = {})
      data, _status_code, _headers = current_item_post_timing_with_http_info(import_item, opts)
      data
    end

    # Post current playing Item
    # Post current playing Item. Can be existing Item referenced by external_id. When Items are moved, this function **will not keep** Items&#39; ModelType structure in rundown.
    # @param import_item [ImportItem] Data **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [Array<(ItemResult, Integer, Hash)>] ItemResult data, response status code and response headers
    def current_item_post_timing_with_http_info(import_item, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.current_item_post_timing ...'
      end
      # verify the required parameter 'import_item' is set
      if @api_client.config.client_side_validation && import_item.nil?
        fail ArgumentError, "Missing the required parameter 'import_item' when calling ItemApi.current_item_post_timing"
      end
      # resource path
      local_var_path = '/items/current/timing'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(import_item)

      # return_type
      return_type = opts[:debug_return_type] || 'ItemResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.current_item_post_timing",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#current_item_post_timing\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete item by ID.
    # Delete item by id.
    # @param id [Integer] ID of Item **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_item_by_id(id, opts = {})
      delete_item_by_id_with_http_info(id, opts)
      nil
    end

    # Delete item by ID.
    # Delete item by id.
    # @param id [Integer] ID of Item **(Required)**
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_item_by_id_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.delete_item_by_id ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling ItemApi.delete_item_by_id"
      end
      # resource path
      local_var_path = '/items/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.delete_item_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#delete_item_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get current Item
    # Get current Item
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :lastplayed Show last played item if there is no current item*(Optional)*
    # @return [ItemResult]
    def get_current_item(opts = {})
      data, _status_code, _headers = get_current_item_with_http_info(opts)
      data
    end

    # Get current Item
    # Get current Item
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :lastplayed Show last played item if there is no current item*(Optional)*
    # @return [Array<(ItemResult, Integer, Hash)>] ItemResult data, response status code and response headers
    def get_current_item_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.get_current_item ...'
      end
      # resource path
      local_var_path = '/items/current'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'lastplayed'] = opts[:'lastplayed'] if !opts[:'lastplayed'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ItemResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.get_current_item",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#get_current_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get extended item details by ID.
    # Read item by id.
    # @param id [Integer] ID of Item **(Required)**
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :_external_station_id Query on a different (content providing) station *(Optional)*
    # @return [ItemResult]
    def get_item_by_id(id, opts = {})
      data, _status_code, _headers = get_item_by_id_with_http_info(id, opts)
      data
    end

    # Get extended item details by ID.
    # Read item by id.
    # @param id [Integer] ID of Item **(Required)**
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :_external_station_id Query on a different (content providing) station *(Optional)*
    # @return [Array<(ItemResult, Integer, Hash)>] ItemResult data, response status code and response headers
    def get_item_by_id_with_http_info(id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.get_item_by_id ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling ItemApi.get_item_by_id"
      end
      # resource path
      local_var_path = '/items/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'_external_station_id'] = opts[:'_external_station_id'] if !opts[:'_external_station_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ItemResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.get_item_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#get_item_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all the items currently in your station.
    # Get a list of all the items currently in your station. This feature supports pagination and will give a maximum results of 50 items back.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :block_id Search on Block ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :broadcast_id Search on Broadcast ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :model_type_id Search on ModelType ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :tag_id Search on Tag ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :campaign_id Search on Campaign ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :contact_id Search on Contact ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :program_draft_id Search on Program Draft ID *(Optional)*
    # @option opts [Integer] :user_draft_id Search on User Draft ID *(Optional)*
    # @option opts [Integer] :station_draft_id Search on Station Draft ID *(Optional)*
    # @option opts [Integer] :program_id Search on Program ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [String] :external_id Search on External ID *(Optional)*
    # @option opts [Integer] :duration_min Minimum duration (seconds) *(Optional)*
    # @option opts [Integer] :duration_max Maximum duration (seconds) *(Optional)*
    # @option opts [String] :status Play Status of item *(Optional)*
    # @option opts [Time] :start_min Minimum start date *(Optional)*
    # @option opts [Time] :start_max Maximum start date *(Optional)*
    # @option opts [Integer] :page Current page *(Optional)* (default to 1)
    # @option opts [Integer] :limit Results per page *(Optional)*
    # @option opts [String] :order_by Field to order the results *(Optional)*
    # @option opts [String] :order_direction Direction of ordering *(Optional)*
    # @option opts [Integer] :_external_station_id Query on a different (content providing) station *(Optional)*
    # @return [InlineResponse2008]
    def list_items(opts = {})
      data, _status_code, _headers = list_items_with_http_info(opts)
      data
    end

    # Get a list of all the items currently in your station.
    # Get a list of all the items currently in your station. This feature supports pagination and will give a maximum results of 50 items back.
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :block_id Search on Block ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :broadcast_id Search on Broadcast ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :model_type_id Search on ModelType ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :tag_id Search on Tag ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :campaign_id Search on Campaign ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :contact_id Search on Contact ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [Integer] :program_draft_id Search on Program Draft ID *(Optional)*
    # @option opts [Integer] :user_draft_id Search on User Draft ID *(Optional)*
    # @option opts [Integer] :station_draft_id Search on Station Draft ID *(Optional)*
    # @option opts [Integer] :program_id Search on Program ID *(Optional)* &#x60;(Relation)&#x60;
    # @option opts [String] :external_id Search on External ID *(Optional)*
    # @option opts [Integer] :duration_min Minimum duration (seconds) *(Optional)*
    # @option opts [Integer] :duration_max Maximum duration (seconds) *(Optional)*
    # @option opts [String] :status Play Status of item *(Optional)*
    # @option opts [Time] :start_min Minimum start date *(Optional)*
    # @option opts [Time] :start_max Maximum start date *(Optional)*
    # @option opts [Integer] :page Current page *(Optional)* (default to 1)
    # @option opts [Integer] :limit Results per page *(Optional)*
    # @option opts [String] :order_by Field to order the results *(Optional)*
    # @option opts [String] :order_direction Direction of ordering *(Optional)*
    # @option opts [Integer] :_external_station_id Query on a different (content providing) station *(Optional)*
    # @return [Array<(InlineResponse2008, Integer, Hash)>] InlineResponse2008 data, response status code and response headers
    def list_items_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.list_items ...'
      end
      if @api_client.config.client_side_validation && !opts[:'duration_min'].nil? && opts[:'duration_min'] < 0
        fail ArgumentError, 'invalid value for "opts[:"duration_min"]" when calling ItemApi.list_items, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'duration_max'].nil? && opts[:'duration_max'] < 0
        fail ArgumentError, 'invalid value for "opts[:"duration_max"]" when calling ItemApi.list_items, must be greater than or equal to 0.'
      end

      allowable_values = ["scheduled", "playing", "played"]
      if @api_client.config.client_side_validation && opts[:'status'] && !allowable_values.include?(opts[:'status'])
        fail ArgumentError, "invalid value for \"status\", must be one of #{allowable_values}"
      end
      if @api_client.config.client_side_validation && !opts[:'page'].nil? && opts[:'page'] < 0
        fail ArgumentError, 'invalid value for "opts[:"page"]" when calling ItemApi.list_items, must be greater than or equal to 0.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] > 50
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling ItemApi.list_items, must be smaller than or equal to 50.'
      end

      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] < 1
        fail ArgumentError, 'invalid value for "opts[:"limit"]" when calling ItemApi.list_items, must be greater than or equal to 1.'
      end

      allowable_values = ["asc", "desc"]
      if @api_client.config.client_side_validation && opts[:'order_direction'] && !allowable_values.include?(opts[:'order_direction'])
        fail ArgumentError, "invalid value for \"order_direction\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/items'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'block_id'] = opts[:'block_id'] if !opts[:'block_id'].nil?
      query_params[:'broadcast_id'] = opts[:'broadcast_id'] if !opts[:'broadcast_id'].nil?
      query_params[:'model_type_id'] = opts[:'model_type_id'] if !opts[:'model_type_id'].nil?
      query_params[:'tag_id'] = opts[:'tag_id'] if !opts[:'tag_id'].nil?
      query_params[:'campaign_id'] = opts[:'campaign_id'] if !opts[:'campaign_id'].nil?
      query_params[:'contact_id'] = opts[:'contact_id'] if !opts[:'contact_id'].nil?
      query_params[:'program_draft_id'] = opts[:'program_draft_id'] if !opts[:'program_draft_id'].nil?
      query_params[:'user_draft_id'] = opts[:'user_draft_id'] if !opts[:'user_draft_id'].nil?
      query_params[:'station_draft_id'] = opts[:'station_draft_id'] if !opts[:'station_draft_id'].nil?
      query_params[:'program_id'] = opts[:'program_id'] if !opts[:'program_id'].nil?
      query_params[:'external_id'] = opts[:'external_id'] if !opts[:'external_id'].nil?
      query_params[:'duration-min'] = opts[:'duration_min'] if !opts[:'duration_min'].nil?
      query_params[:'duration-max'] = opts[:'duration_max'] if !opts[:'duration_max'].nil?
      query_params[:'status'] = opts[:'status'] if !opts[:'status'].nil?
      query_params[:'start-min'] = opts[:'start_min'] if !opts[:'start_min'].nil?
      query_params[:'start-max'] = opts[:'start_max'] if !opts[:'start_max'].nil?
      query_params[:'page'] = opts[:'page'] if !opts[:'page'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'order-by'] = opts[:'order_by'] if !opts[:'order_by'].nil?
      query_params[:'order-direction'] = opts[:'order_direction'] if !opts[:'order_direction'].nil?
      query_params[:'_external_station_id'] = opts[:'_external_station_id'] if !opts[:'_external_station_id'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse2008'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.list_items",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#list_items\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Post a playlist, do not remove previously imported items
    # Post a playlist with 'keep structure' method, but do not remove previously imported items
    # @param playlist_merge_body [PlaylistMergeBody] Data *(Required)*
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2021]
    def playlist_post_merge(playlist_merge_body, opts = {})
      data, _status_code, _headers = playlist_post_merge_with_http_info(playlist_merge_body, opts)
      data
    end

    # Post a playlist, do not remove previously imported items
    # Post a playlist with &#39;keep structure&#39; method, but do not remove previously imported items
    # @param playlist_merge_body [PlaylistMergeBody] Data *(Required)*
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2021, Integer, Hash)>] InlineResponse2021 data, response status code and response headers
    def playlist_post_merge_with_http_info(playlist_merge_body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.playlist_post_merge ...'
      end
      # verify the required parameter 'playlist_merge_body' is set
      if @api_client.config.client_side_validation && playlist_merge_body.nil?
        fail ArgumentError, "Missing the required parameter 'playlist_merge_body' when calling ItemApi.playlist_post_merge"
      end
      # resource path
      local_var_path = '/items/playlist/merge'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(playlist_merge_body)

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse2021'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.playlist_post_merge",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#playlist_post_merge\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Post a playlist, keep current structure
    # Post a playlist for a block. Existing Items can referenced by external_id. When Items are moved, this function **will attempt to** keep Items' ModelType structure in rundown.
    # @param playlist_structure_body [PlaylistStructureBody] Data *(Required)*
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2021]
    def playlist_post_structure(playlist_structure_body, opts = {})
      data, _status_code, _headers = playlist_post_structure_with_http_info(playlist_structure_body, opts)
      data
    end

    # Post a playlist, keep current structure
    # Post a playlist for a block. Existing Items can referenced by external_id. When Items are moved, this function **will attempt to** keep Items&#39; ModelType structure in rundown.
    # @param playlist_structure_body [PlaylistStructureBody] Data *(Required)*
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2021, Integer, Hash)>] InlineResponse2021 data, response status code and response headers
    def playlist_post_structure_with_http_info(playlist_structure_body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.playlist_post_structure ...'
      end
      # verify the required parameter 'playlist_structure_body' is set
      if @api_client.config.client_side_validation && playlist_structure_body.nil?
        fail ArgumentError, "Missing the required parameter 'playlist_structure_body' when calling ItemApi.playlist_post_structure"
      end
      # resource path
      local_var_path = '/items/playlist/structure'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(playlist_structure_body)

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse2021'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.playlist_post_structure",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#playlist_post_structure\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Post a playlist
    # Post a playlist for a block. Existing Items can referenced by external_id. When Items are moved, this function **will not** keep Items' ModelType structure in rundown.
    # @param playlist_timing_body [PlaylistTimingBody] Data *(Required)*
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse2021]
    def playlist_post_timing(playlist_timing_body, opts = {})
      data, _status_code, _headers = playlist_post_timing_with_http_info(playlist_timing_body, opts)
      data
    end

    # Post a playlist
    # Post a playlist for a block. Existing Items can referenced by external_id. When Items are moved, this function **will not** keep Items&#39; ModelType structure in rundown.
    # @param playlist_timing_body [PlaylistTimingBody] Data *(Required)*
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse2021, Integer, Hash)>] InlineResponse2021 data, response status code and response headers
    def playlist_post_timing_with_http_info(playlist_timing_body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.playlist_post_timing ...'
      end
      # verify the required parameter 'playlist_timing_body' is set
      if @api_client.config.client_side_validation && playlist_timing_body.nil?
        fail ArgumentError, "Missing the required parameter 'playlist_timing_body' when calling ItemApi.playlist_post_timing"
      end
      # resource path
      local_var_path = '/items/playlist/timing'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(playlist_timing_body)

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse2021'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.playlist_post_timing",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#playlist_post_timing\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Stop an Item
    # Set a current playing or specific item on played
    # @param [Hash] opts the optional parameters
    # @option opts [ItemsStopcurrentBody] :items_stopcurrent_body Data *(Optional)*
    # @return [InlineResponse202]
    def stop_current_item(opts = {})
      data, _status_code, _headers = stop_current_item_with_http_info(opts)
      data
    end

    # Stop an Item
    # Set a current playing or specific item on played
    # @param [Hash] opts the optional parameters
    # @option opts [ItemsStopcurrentBody] :items_stopcurrent_body Data *(Optional)*
    # @return [Array<(InlineResponse202, Integer, Hash)>] InlineResponse202 data, response status code and response headers
    def stop_current_item_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.stop_current_item ...'
      end
      # resource path
      local_var_path = '/items/stopcurrent'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'items_stopcurrent_body'])

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse202'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.stop_current_item",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#stop_current_item\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update extended item details by ID.
    # Update item by id.
    # @param id [Integer] ID of Item **(Required)**
    # @param item_data_input [ItemDataInput] Data *(Optional)*
    # @param [Hash] opts the optional parameters
    # @return [InlineResponse202]
    def update_item_by_id(id, item_data_input, opts = {})
      data, _status_code, _headers = update_item_by_id_with_http_info(id, item_data_input, opts)
      data
    end

    # Update extended item details by ID.
    # Update item by id.
    # @param id [Integer] ID of Item **(Required)**
    # @param item_data_input [ItemDataInput] Data *(Optional)*
    # @param [Hash] opts the optional parameters
    # @return [Array<(InlineResponse202, Integer, Hash)>] InlineResponse202 data, response status code and response headers
    def update_item_by_id_with_http_info(id, item_data_input, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ItemApi.update_item_by_id ...'
      end
      # verify the required parameter 'id' is set
      if @api_client.config.client_side_validation && id.nil?
        fail ArgumentError, "Missing the required parameter 'id' when calling ItemApi.update_item_by_id"
      end
      # verify the required parameter 'item_data_input' is set
      if @api_client.config.client_side_validation && item_data_input.nil?
        fail ArgumentError, "Missing the required parameter 'item_data_input' when calling ItemApi.update_item_by_id"
      end
      # resource path
      local_var_path = '/items/{id}'.sub('{' + 'id' + '}', CGI.escape(id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(item_data_input)

      # return_type
      return_type = opts[:debug_return_type] || 'InlineResponse202'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['API-Key']

      new_options = opts.merge(
        :operation => :"ItemApi.update_item_by_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ItemApi#update_item_by_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
